@tool
@icon("res://icon.svg") # Make sure you have an icon.svg or remove this line
extends Node3D
class_name CactusGenerator

@export var config: CactusConfig
#@export var growth_duration: float = 1.5 # Duration of the growth animation
#@export var regenerate := false:
	#set(value):
		#if value:
			## Check if nodes are ready before generating when using the setter
			#if not is_node_ready():
				## If not ready, wait for the next idle frame
				#await get_tree().process_frame
				#generate()
		#regenerate = false

@onready var cactus_mesh_instance := $CactusMesh as MeshInstance3D
@onready var spike_multimesh := $Spikes as MultiMeshInstance3D

var cactus_shader: ShaderMaterial
var rng := RandomNumberGenerator.new()
var growth_tween: Tween # Variable to hold our tween

func _ready():
	if Engine.is_editor_hint():
		# Delay generation slightly to ensure config might be loaded
		await get_tree().process_frame
		if config:
			generate()
			# Don't auto-animate on ready, only on regenerate toggle
			# Set growth to 1 initially if not animating on ready
			if is_instance_valid(cactus_shader):
				cactus_shader.set_shader_parameter("growth", 1.0)

func generate():
	# --- Start of Checks ---
	if not config:
		push_warning("CactusGenerator: No CactusConfig resource assigned.")
		return
	var mesh_inst = get_node_or_null("CactusMesh") as MeshInstance3D
	var multi_mesh_inst = get_node_or_null("Spikes") as MultiMeshInstance3D
	if not mesh_inst:
		push_error("CactusGenerator: Child node 'CactusMesh' (MeshInstance3D) not found or invalid.")
		return
		
	if not multi_mesh_inst:
		push_error("CactusGenerator: Child node 'Spikes' (MultiMeshInstance3D) not found or invalid.")
		return
	# --- End of Checks ---

	cactus_mesh_instance = mesh_inst
	spike_multimesh = multi_mesh_inst

	# Proceed with generation
	rng.seed = config.seed
	var generated_height = _generate_cactus() # Function now returns the calculated max height

	# Check if mesh generation was successful (returned height > 0)
	if generated_height > 0.0:
		_place_spikes() # Spikes appear instantly

		# --- Trigger the growth animation ---
		# Pass the actual generated height to the animation function
		animate_growth(generated_height)
		# --- End Trigger ---
		print("Cactus generated! Starting growth animation.")
	else:
		print("Cactus generation failed.")


# --- MODIFIED: Returns calculated max height or 0.0 on failure ---
# --- MODIFIED: Returns calculated max height or 0.0 on failure ---
func _generate_cactus() -> float:
	# Ensure the instance is valid
	if not is_instance_valid(cactus_mesh_instance):
		push_error("Cannot assign mesh, CactusMesh instance is invalid.")
		return 0.0 # Return 0 on failure

	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)	# --- Config and Cap Parameters ---
	# (Code remains the same)
	var h = config.cactus_height
	var rs = config.ring_resolution
	var rc = config.ring_count
	var angle_step = TAU / float(rs)
	var cap_ring_count: int = 3
	var cap_height_factor: float = 0.6

	# --- Step 1: Define all unique vertex positions ---
	# (Code remains the same - includes main rings and cap rings)
	var vertices = PackedVector3Array()
	var uvs = PackedVector2Array()
	var ring_start_indices = []
	var last_main_ring_radius = 0.0
	# ... (vertex generation code for main rings) ...
	for i in range(rc + 1):
		var t = float(i) / rc
		var y = t * h
		var r = max(0.01, config.radius * (0.85 + rng.randf_range(0, 0.3)) * _rim_shape(t))
		ring_start_indices.append(vertices.size())
		if i == rc: last_main_ring_radius = r
		for j in range(rs):
			var angle = j * angle_step
			var x = cos(angle) * r
			var z = sin(angle) * r
			vertices.append(Vector3(x, y, z))
			var uv_x = float(j) / rs
			var uv_y = t
			uvs.append(Vector2(uv_x, uv_y))
			
	# ... (vertex generation code for cap rings)
	var cap_base_y = h
	var cap_base_r = last_main_ring_radius
	var cap_height = cap_base_r * cap_height_factor
	var max_h = cap_base_y + cap_height # Total height including cap
	# ... (sphere calculations) ...
	var sphere_r_denom = 2.0 * cap_height
	var sphere_r = cap_base_r * cap_base_r if sphere_r_denom <= 0.001 else (cap_base_r * cap_base_r + cap_height * cap_height) / sphere_r_denom
	var sphere_center_y = cap_base_y + cap_height - sphere_r
	var start_angle_cos = (cap_base_y - sphere_center_y) / sphere_r if sphere_r > 0.001 else 0.0
	var start_angle = acos(clampf(start_angle_cos, -1.0, 1.0))
	for k in range(1, cap_ring_count + 1):
		var cap_t = float(k) / cap_ring_count
		var current_angle = lerpf(start_angle, 0.0, cap_t)
		var r = sphere_r * sin(current_angle)
		var y = sphere_center_y + sphere_r * cos(current_angle)
		ring_start_indices.append(vertices.size())
		var uv_cap_y = lerpf(float(rc) / (rc + cap_ring_count), 1.0, cap_t)
		for j in range(rs):
			var angle = j * angle_step
			var x = cos(angle) * r
			var z = sin(angle) * r
			vertices.append(Vector3(x, y, z))
			var uv_x = float(j) / rs
			uvs.append(Vector2(uv_x, uv_cap_y))
			
	# ... (add top center vertex) ...
	var top_center_pos = Vector3(0, max_h, 0)
	var top_center_idx = vertices.size()
	vertices.append(top_center_pos)
	uvs.append(Vector2(0.5, 1.0))


	# --- Step 2: Add vertices and attributes ---
	# (Code remains the same)
	for i in range(vertices.size()):
		st.set_uv(uvs[i])
		st.add_vertex(vertices[i])

	# --- Step 3: Add indices for sides ---
	# (Code remains the same)
	var total_rings = rc + cap_ring_count
	for i in range(total_rings):
		var idx_a = ring_start_indices[i]
		var idx_b = ring_start_indices[i+1]
		for j in range(rs):
			var v_a_j = idx_a + j
			var v_a_next = idx_a + (j + 1) % rs
			var v_b_j = idx_b + j
			var v_b_next = idx_b + (j + 1) % rs
			# Tri 1 (CCW)
			st.add_index(v_a_j); st.add_index(v_b_next); st.add_index(v_b_j)
			# Tri 2 (CCW)
			st.add_index(v_a_j); st.add_index(v_a_next); st.add_index(v_b_next)

	# --- Step 4: Add indices for top cap ---
	# (Code remains the same)
	var idx_top_ring_start = ring_start_indices[total_rings]
	for j in range(rs):
		var v_top_j = idx_top_ring_start + j
		var v_top_next = idx_top_ring_start + (j + 1) % rs
		# Cap Tri (CCW)
		st.add_index(top_center_idx); st.add_index(v_top_j); st.add_index(v_top_next)

	# --- Step 5: Generate normals and commit ---
	st.generate_normals()
	# st.generate_tangents()

	# Commit to a new mesh resource
	var mesh = st.commit()
	if not mesh:
		push_error("Failed to commit SurfaceTool mesh.")
		return 0.0 # Return 0 on failure
		
	# --- >> NEW << Revised Shader and Material Setup ---
	# 1. Create and validate the Shader resource first
	var shader_res = Shader.new()
	shader_res.code = _growth_shader()

	if shader_res.code.is_empty():
		push_error("Growth shader code is empty. Cannot setup material.")
		cactus_mesh_instance.material_override = null # Use default material
		cactus_mesh_instance.mesh = mesh
		return 0.0 # Indicate failure	# 2. ALWAYS create a new ShaderMaterial instance
	var new_material = ShaderMaterial.new() 

	# 3. Assign the validated Shader to the NEW ShaderMaterial
	new_material.shader = shader_res

	# 4. Assign the mesh and the NEW material override
	cactus_mesh_instance.mesh = mesh
	cactus_mesh_instance.material_override = new_material # Assign the fresh material

	# 5. Set shader parameters on the NEW material instance
	new_material.set_shader_parameter("total_height", max_h)
	new_material.set_shader_parameter("growth", 0.0) # Start growth at 0

	# 6. Update the class variable to hold the reference to the NEW material
	# This is needed so the animate_growth function can find it
	cactus_shader = new_material 
	# --- >> END NEW << Revised Setup ---

	# Return calculated height for animation function
	return max_h



# --- MODIFIED: Accepts generated_height parameter ---
# --- MODIFIED: Accepts generated_height parameter + Extra Check ---
func animate_growth(generated_height: float):
	# Ensure we have a valid material to animate (using the class variable)
	if not is_instance_valid(cactus_shader) or not cactus_shader is ShaderMaterial:
		push_warning("Cannot animate growth: Class ShaderMaterial variable is invalid.")
		return
		
	# >>> ADDED CHECK: Ensure the shader *inside* the material is valid <<<
	if not is_instance_valid(cactus_shader.shader):
		push_warning("Cannot animate growth: Shader resource inside ShaderMaterial is invalid.")
		# Set growth to 1 directly if shader is bad, so mesh is at least visible
		cactus_shader.set_shader_parameter("growth", 1.0) 
		return
	# >>> END ADDED CHECK <<<

	# Ensure generated_height is valid
	if generated_height <= 0.0:
		push_warning("Cannot animate growth: Invalid generated_height (%f)." % generated_height)
		# Set growth to 1 directly if height is invalid
		cactus_shader.set_shader_parameter("growth", 1.0)
		return

	# Validate growth_duration
	var duration: float = config.growth_duration if config and config.growth_duration > 0.0 else 1.5

	# If a previous tween is running, kill it
	if is_instance_valid(growth_tween) and growth_tween.is_running():
		growth_tween.kill()

	# --- Update total_height uniform just before animating ---
	cactus_shader.set_shader_parameter("total_height", generated_height)
	# --- Ensure growth starts at 0 ---
	cactus_shader.set_shader_parameter("growth", 0.0)

	# Create a new tween
	growth_tween = create_tween()
	growth_tween.set_process_mode(Tween.TWEEN_PROCESS_PHYSICS) # Use PHYSICS for editor
	growth_tween.set_parallel(false)
	print("Starting tween for growth parameter to 1.0 over %f seconds" % duration)
	# Tween the "growth" shader parameter from 0.0 to 1.0
	growth_tween.tween_property(cactus_shader, "shader_parameter/growth", 1.0, duration)\
		.from(0.0)\
		.set_trans(Tween.TRANS_QUAD)\
		.set_ease(Tween.EASE_OUT)

	# Optional callback
	# growth_tween.tween_callback(_on_growth_finished)



func _rim_shape(t: float) -> float:
	# (Code remains the same)
	t = clampf(t, 0.0, 1.0)
	return 0.5 + 0.5 * sin((t - 0.5) * PI) * config.rim_roundness

func _spike_mesh() -> Mesh:
	# (Code remains the same, with corrected winding order)
	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)
	var tip = Vector3(0, 0.1, 0); var base = 0.02
	st.add_vertex(Vector3(-base, 0, -base)) # 0
	st.add_vertex(Vector3( base, 0, -base)) # 1
	st.add_vertex(Vector3( base, 0,  base)) # 2
	st.add_vertex(Vector3(-base, 0,  base)) # 3
	st.add_vertex(tip)                      # 4
	# Corrected Winding Order
	st.add_index(4); st.add_index(0); st.add_index(1)
	st.add_index(4); st.add_index(1); st.add_index(2)
	st.add_index(4); st.add_index(2); st.add_index(3)
	st.add_index(4); st.add_index(3); st.add_index(0)
	st.generate_normals()
	return st.commit()

func _place_spikes():
	# Ensure the instance is valid one last time before assignment
	if not is_instance_valid(spike_multimesh):
		push_error("Cannot assign multimesh, Spikes instance is invalid.")
		return

	var mm = MultiMesh.new()
	# --- MultiMesh Setup Order ---
	mm.transform_format = MultiMesh.TRANSFORM_3D # Set format FIRST
	mm.mesh = _spike_mesh()                     # Assign mesh
	
	# Check if spike mesh is valid
	if not mm.mesh:
		push_error("Failed to create spike mesh for MultiMesh.")
		return
		
	mm.instance_count = config.spike_count      # Set count LAST
	# --- End Setup ---

	# Assign multimesh
	spike_multimesh.multimesh = mm

	# Check if count is > 0 before looping
	if config.spike_count <= 0:
		return

	# Pre-calculate some values for the loop
	var safe_ring_res = max(1, config.ring_resolution)
	var radius_spike = max(0.01, config.radius * 1.05)
	var spike_scale_val = 0.1 # Adjust scale as needed
	var spike_scale_vec = Vector3.ONE * spike_scale_val

	for i in range(config.spike_count):
		var t = float(i) / config.spike_count
		# Place spikes based on the *original* configured height, not the potentially capped height
		var y = t * config.cactus_height 
		var angle = 0.0 # Initialize angle

		# Use safe division for ring pattern
		if config.spike_pattern == "spiral":
			angle = TAU * t * 3.0 + rng.randf_range(0, 0.2)
		else: # Assuming "ring" or default
			angle = float(i % safe_ring_res) * TAU / safe_ring_res

		# Calculate spike position
		var x = cos(angle) * radius_spike
		var z = sin(angle) * radius_spike
		var pos = Vector3(x, y, z)

		# Calculate basis looking outwards from center (approximately)
		var dir = Vector3(x, 0, z).normalized() # Direction on the XZ plane
		if dir.length_squared() < 0.001: # Check if close to zero (e.g., at origin)
			dir = Vector3.FORWARD # Default direction if at origin
		var basis = Basis.looking_at(dir, Vector3.UP)

		# Set instance transform
		mm.set_instance_transform(i, Transform3D(basis.scaled(spike_scale_vec), pos))



# --- MODIFIED: Removed color uniform ---
func _growth_shader() -> String:
	# Shader that clips geometry based on original Y position and growth uniform
	return """
shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back;uniform float growth : hint_range(0.0, 1.0) = 0.0;
uniform float total_height = 1.0; // Set by script

// Varying to pass original Y position to fragment shader
varying float original_y;

void vertex() {
	original_y = VERTEX.y; // Store original Y before modification
	// Vertex position is not scaled here anymore
}

void fragment() {	float current_max_y = growth * total_height;

	// Discard fragment if its original Y is above the current growth height
	if (original_y > current_max_y + 0.001) { // Add small tolerance
		discard;
	}

	// Default white color
	ALBEDO = vec3(1.0);
	ALPHA = 0.5; 
	
	// Default PBR values
	ROUGHNESS = 0.8;
	METALLIC = 0.1;
}
"""
